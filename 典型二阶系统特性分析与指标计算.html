<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>典型二阶系统特性分析与指标计算</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #34495e;
            --success-color: #2ecc71;
            --warning-color: #f39c12;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: var(--primary-color);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1.5fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .control-panel {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .panel-title {
            font-size: 1.3rem;
            margin-bottom: 20px;
            color: var(--secondary-color);
            border-bottom: 2px solid var(--light-color);
            padding-bottom: 10px;
        }
        
        .parameter-control {
            margin-bottom: 25px;
        }
        
        .slider-container {
            margin-bottom: 15px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .slider-value {
            font-weight: bold;
            color: var(--secondary-color);
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: var(--light-color);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--secondary-color);
            cursor: pointer;
        }
        
        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background-color: var(--secondary-color);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background-color: var(--primary-color);
            transform: translateY(-2px);
        }
        
        .active {
            background-color: var(--accent-color);
        }
        
        .transfer-function {
            background-color: var(--light-color);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            font-family: 'Cambria Math', serif;
            font-size: 1.2rem;
            margin-bottom: 20px;
        }
        
        .input-signal-selector {
            margin-bottom: 20px;
        }
        
        .signal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .signal-btn {
            flex: 1;
        }
        
        .performance-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .metric-card {
            background-color: var(--light-color);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.2rem;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .formulas-container {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        
        .formula {
            margin-bottom: 15px;
            padding: 10px;
            background-color: var(--light-color);
            border-radius: 5px;
            font-family: 'Cambria Math', serif;
        }
        
        .chart-container {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .chart-wrapper {
            position: relative;
            width: 100%;
            height: 400px;
            border: 1px solid #eee;
            border-radius: 5px;
            overflow: hidden;
        }
        
        canvas {
            width: 100%;
            height: 100%;
        }
        
        .chart-title {
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .system-description {
            margin-top: 15px;
            padding: 10px;
            background-color: var(--light-color);
            border-radius: 5px;
            font-style: italic;
        }
        
        .design-lab {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
        }
        
        .design-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .target-parameters {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .target-param {
            padding: 10px;
            border-radius: 5px;
            background-color: var(--light-color);
        }
        
        .target-input {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        
        .requirement {
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            background-color: var(--light-color);
        }
        
        .requirement-met {
            background-color: var(--success-color);
            color: white;
        }
        
        .requirement-not-met {
            background-color: var(--accent-color);
            color: white;
        }
        
        .success-message {
            text-align: center;
            padding: 15px;
            background-color: var(--success-color);
            color: white;
            border-radius: 5px;
            margin-top: 15px;
            display: none;
        }
        
        .expert-solution {
            margin-top: 15px;
            text-align: center;
        }
        
        .expert-params {
            margin-top: 10px;
            padding: 10px;
            background-color: var(--light-color);
            border-radius: 5px;
            display: none;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding: 15px;
            color: var(--dark-color);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>典型二阶系统特性分析与指标计算</h1>
            <p class="subtitle">交互式仿真实验 - 自动控制原理课程</p>
        </header>
        
        <div class="main-content">
            <div class="control-panel">
                <h2 class="panel-title">系统参数控制</h2>
                
                <div class="parameter-control">
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>阻尼比 ζ</span>
                            <span class="slider-value" id="zeta-value">0.7</span>
                        </div>
                        <input type="range" id="zeta-slider" min="0" max="2" step="0.01" value="0.7">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>自然频率 ω<sub>n</sub> (rad/s)</span>
                            <span class="slider-value" id="omega-value">5</span>
                        </div>
                        <input type="range" id="omega-slider" min="0.5" max="10" step="0.1" value="5">
                    </div>
                </div>
                
                <h3 class="panel-title">预设系统状态</h3>
                <div class="preset-buttons">
                    <button id="undamped-btn">无阻尼振荡 (ζ=0)</button>
                    <button id="underdamped-btn">欠阻尼 (ζ=0.2)</button>
                    <button id="critical-btn">临界阻尼 (ζ=1)</button>
                    <button id="overdamped-btn">过阻尼 (ζ=1.5)</button>
                </div>
                
                <h3 class="panel-title">输入信号选择</h3>
                <div class="input-signal-selector">
                    <div class="signal-buttons">
                        <button class="signal-btn active" data-signal="step">单位阶跃</button>
                        <button class="signal-btn" data-signal="ramp">单位斜坡</button>
                        <button class="signal-btn" data-signal="impulse">单位脉冲</button>
                    </div>
                </div>
                
                <h3 class="panel-title">传递函数</h3>
                <div class="transfer-function" id="transfer-function">
                    G(s) = 25 / (s² + 7s + 25)
                </div>
                
                <h3 class="panel-title">性能指标</h3>
                <div class="performance-metrics">
                    <div class="metric-card">
                        <div>上升时间 t<sub>r</sub></div>
                        <div class="metric-value" id="rise-time">0.36 s</div>
                    </div>
                    <div class="metric-card">
                        <div>峰值时间 t<sub>p</sub></div>
                        <div class="metric-value" id="peak-time">0.65 s</div>
                    </div>
                    <div class="metric-card">
                        <div>超调量 M<sub>p</sub></div>
                        <div class="metric-value" id="overshoot">4.6 %</div>
                    </div>
                    <div class="metric-card">
                        <div>调节时间 t<sub>s</sub></div>
                        <div class="metric-value" id="settling-time">1.14 s</div>
                    </div>
                </div>
                
                <div class="system-description" id="system-description">
                    当前为欠阻尼状态：响应快速但有轻微振荡和超调。
                </div>
            </div>
            
            <div class="chart-container">
                <h2 class="panel-title">系统响应</h2>
                <div class="chart-wrapper">
                    <canvas id="response-chart"></canvas>
                </div>
                <div class="chart-title" id="chart-title">单位阶跃响应</div>
            </div>
        </div>
        
        <div class="formulas-container">
            <h2 class="panel-title">性能指标计算公式</h2>
            <div class="formula">
                <strong>上升时间 t<sub>r</sub>:</strong> t<sub>r</sub> = (π - φ) / ω<sub>d</sub><br>
                其中 φ = arccos(ζ), ω<sub>d</sub> = ω<sub>n</sub>√(1-ζ²)
            </div>
            <div class="formula">
                <strong>峰值时间 t<sub>p</sub>:</strong> t<sub>p</sub> = π / ω<sub>d</sub><br>
                其中 ω<sub>d</sub> = ω<sub>n</sub>√(1-ζ²)
            </div>
            <div class="formula">
                <strong>超调量 M<sub>p</sub>:</strong> M<sub>p</sub> = e<sup>-ζπ/√(1-ζ²)</sup> × 100%
            </div>
            <div class="formula">
                <strong>调节时间 t<sub>s</sub>:</strong> t<sub>s</sub> ≈ 4 / (ζω<sub>n</sub>) (2%准则)<br>
                或 t<sub>s</sub> ≈ 3 / (ζω<sub>n</sub>) (5%准则)
            </div>
        </div>
        
        <div class="design-lab">
            <h2 class="panel-title">控制器设计实验室</h2>
            <p>请调整系统参数，使系统满足以下性能要求：</p>
            
            <div class="design-controls">
                <div class="target-parameters">
                    <div class="target-param">
                        <div>目标超调量 M<sub>p</sub> <</div>
                        <input type="number" id="target-overshoot" class="target-input" min="0" max="100" step="0.1" value="5"> %
                    </div>
                    <div class="target-param">
                        <div>目标调节时间 t<sub>s</sub> <</div>
                        <input type="number" id="target-settling-time" class="target-input" min="0" max="20" step="0.1" value="4"> s
                    </div>
                </div>
                
                <div class="design-requirements">
                    <div class="requirement" id="req-overshoot">
                        <div>超调量 M<sub>p</sub> < <span id="target-overshoot-value">5</span>%</div>
                        <div class="metric-value">4.6% ✓</div>
                    </div>
                    <div class="requirement" id="req-settling-time">
                        <div>调节时间 t<sub>s</sub> < <span id="target-settling-value">4</span>s</div>
                        <div class="metric-value">1.14s ✓</div>
                    </div>
                </div>
            </div>
            
            <div class="success-message" id="success-message">
                <h3>设计成功！</h3>
                <p>您的系统满足了所有性能要求！</p>
            </div>
            
            <div class="expert-solution">
                <button id="expert-solution-btn">显示专家解</button>
                <div class="expert-params" id="expert-solution">
                    <p>专家建议参数：</p>
                    <p>阻尼比 ζ = <span id="expert-zeta">0.7</span></p>
                    <p>自然频率 ω<sub>n</sub> = <span id="expert-omega">5</span> rad/s</p>
                </div>
            </div>
        </div>
        
        <footer>
            <p>典型二阶系统特性分析与指标计算仿真实验 | 自动化专业控制理论课程</p>
        </footer>
    </div>

    <script>
        // 全局变量
        let zeta = 0.7;
        let omega_n = 5;
        let currentSignal = 'step'; // 默认输入信号为阶跃信号
        let canvas, ctx;
        
        // DOM元素
        const zetaSlider = document.getElementById('zeta-slider');
        const omegaSlider = document.getElementById('omega-slider');
        const zetaValue = document.getElementById('zeta-value');
        const omegaValue = document.getElementById('omega-value');
        const transferFunction = document.getElementById('transfer-function');
        const riseTimeElem = document.getElementById('rise-time');
        const peakTimeElem = document.getElementById('peak-time');
        const overshootElem = document.getElementById('overshoot');
        const settlingTimeElem = document.getElementById('settling-time');
        const systemDescription = document.getElementById('system-description');
        const reqOvershoot = document.getElementById('req-overshoot');
        const reqSettlingTime = document.getElementById('req-settling-time');
        const successMessage = document.getElementById('success-message');
        const expertSolutionBtn = document.getElementById('expert-solution-btn');
        const expertSolution = document.getElementById('expert-solution');
        const expertZeta = document.getElementById('expert-zeta');
        const expertOmega = document.getElementById('expert-omega');
        const targetOvershootInput = document.getElementById('target-overshoot');
        const targetSettlingTimeInput = document.getElementById('target-settling-time');
        const targetOvershootValue = document.getElementById('target-overshoot-value');
        const targetSettlingValue = document.getElementById('target-settling-value');
        const chartTitle = document.getElementById('chart-title');
        
        // 初始化Canvas
        function initCanvas() {
            canvas = document.getElementById('response-chart');
            ctx = canvas.getContext('2d');
            
            // 设置Canvas尺寸
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // 初始绘制
            updateSystem();
        }
        
        // 预设按钮
        document.getElementById('undamped-btn').addEventListener('click', () => setParameters(0, 5));
        document.getElementById('underdamped-btn').addEventListener('click', () => setParameters(0.2, 5));
        document.getElementById('critical-btn').addEventListener('click', () => setParameters(1, 5));
        document.getElementById('overdamped-btn').addEventListener('click', () => setParameters(1.5, 5));
        
        // 滑块事件
        zetaSlider.addEventListener('input', function() {
            zeta = parseFloat(this.value);
            zetaValue.textContent = zeta.toFixed(2);
            updateSystem();
        });
        
        omegaSlider.addEventListener('input', function() {
            omega_n = parseFloat(this.value);
            omegaValue.textContent = omega_n.toFixed(1);
            updateSystem();
        });
        
        // 输入信号选择
        const signalButtons = document.querySelectorAll('.signal-btn');
        signalButtons.forEach(button => {
            button.addEventListener('click', function() {
                signalButtons.forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
                currentSignal = this.getAttribute('data-signal');
                updateSystem();
            });
        });
        
        // 目标参数输入事件
        targetOvershootInput.addEventListener('input', function() {
            targetOvershootValue.textContent = this.value;
            updateDesignLab();
            calculateExpertSolution();
        });
        
        targetSettlingTimeInput.addEventListener('input', function() {
            targetSettlingValue.textContent = this.value;
            updateDesignLab();
            calculateExpertSolution();
        });
        
        // 专家解按钮
        expertSolutionBtn.addEventListener('click', function() {
            expertSolution.style.display = expertSolution.style.display === 'none' ? 'block' : 'none';
        });
        
        // 设置参数
        function setParameters(newZeta, newOmega) {
            zeta = newZeta;
            omega_n = newOmega;
            
            zetaSlider.value = zeta;
            omegaSlider.value = omega_n;
            zetaValue.textContent = zeta.toFixed(2);
            omegaValue.textContent = omega_n.toFixed(1);
            
            updateSystem();
        }
        
        // 绘制图表
        function drawChart(timeData, responseData, inputData) {
            if (!ctx) return;
            
            const width = canvas.width;
            const height = canvas.height;
            const padding = { top: 20, right: 20, bottom: 40, left: 60 };
            const graphWidth = width - padding.left - padding.right;
            const graphHeight = height - padding.top - padding.bottom;
            
            // 清空画布
            ctx.clearRect(0, 0, width, height);
            
            // 绘制背景网格
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            
            // 水平网格线
            for (let i = 0; i <= 10; i++) {
                const y = padding.top + (i / 10) * graphHeight;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
            }
            
            // 垂直网格线
            for (let i = 0; i <= 10; i++) {
                const x = padding.left + (i / 10) * graphWidth;
                ctx.beginPath();
                ctx.moveTo(x, padding.top);
                ctx.lineTo(x, height - padding.bottom);
                ctx.stroke();
            }
            
            // 绘制坐标轴
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            
            // X轴
            ctx.beginPath();
            ctx.moveTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.stroke();
            
            // Y轴
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.stroke();
            
            // 坐标轴标签
            ctx.fillStyle = '#000';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            // X轴标签
            ctx.fillText('时间 (s)', padding.left + graphWidth / 2, height - padding.bottom + 20);
            
            // Y轴标签
            ctx.save();
            ctx.translate(10, padding.top + graphHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('幅值', 0, 0);
            ctx.restore();
            
            // X轴刻度
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            for (let i = 0; i <= 5; i++) {
                const x = padding.left + (i / 5) * graphWidth;
                ctx.fillText(i.toString(), x, height - padding.bottom + 5);
            }
            
            // Y轴刻度
            const yMax = currentSignal === 'ramp' ? 8 : 
                         currentSignal === 'impulse' ? Math.max(omega_n, 2) : 2;
            
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let i = 0; i <= 5; i++) {
                const y = height - padding.bottom - (i / 5) * graphHeight;
                const value = (i / 5) * yMax;
                ctx.fillText(value.toFixed(1), padding.left - 10, y);
            }
            
            // 绘制输入信号
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            
            for (let i = 0; i < inputData.length; i++) {
                const x = padding.left + (timeData[i] / 8) * graphWidth;
                const y = height - padding.bottom - (inputData[i] / yMax) * graphHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 绘制系统响应
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            ctx.beginPath();
            
            for (let i = 0; i < responseData.length; i++) {
                const x = padding.left + (timeData[i] / 8) * graphWidth;
                const y = height - padding.bottom - (responseData[i] / yMax) * graphHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 绘制图例
            ctx.fillStyle = '#2c3e50';
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('输入信号', width - padding.right - 100, padding.top + 10);
            
            ctx.fillStyle = '#3498db';
            ctx.fillText('系统响应', width - padding.right - 100, padding.top + 30);
            
            // 绘制图例线
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(width - padding.right - 120, padding.top + 15);
            ctx.lineTo(width - padding.right - 100, padding.top + 15);
            ctx.stroke();
            
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(width - padding.right - 120, padding.top + 35);
            ctx.lineTo(width - padding.right - 100, padding.top + 35);
            ctx.stroke();
        }
        
        // 更新系统
        function updateSystem() {
            // 更新传递函数显示
            const a = 2 * zeta * omega_n;
            const b = omega_n * omega_n;
            transferFunction.innerHTML = `G(s) = ${b.toFixed(2)} / (s² + ${a.toFixed(2)}s + ${b.toFixed(2)})`;
            
            // 更新图表标题
            chartTitle.textContent = getSignalName(currentSignal) + '响应';
            
            // 计算系统响应
            const timeData = [];
            const responseData = [];
            const inputData = [];
            
            const omega_d = omega_n * Math.sqrt(1 - zeta * zeta); // 阻尼自然频率
            
            for (let t = 0; t <= 8; t += 0.05) {
                timeData.push(t);
                
                // 计算输入信号
                let inputValue = 0;
                if (currentSignal === 'step') {
                    inputValue = t >= 0 ? 1 : 0;
                } else if (currentSignal === 'ramp') {
                    inputValue = t >= 0 ? t : 0;
                } else if (currentSignal === 'impulse') {
                    // 单位脉冲近似为非常短时间的高幅值信号
                    inputValue = t >= 0 && t < 0.05 ? 1 : 0;
                }
                inputData.push(inputValue);
                
                // 计算系统响应
                let responseValue = 0;
                
                if (currentSignal === 'step') {
                    // 阶跃响应
                    if (zeta === 0) {
                        // 无阻尼
                        responseValue = 1 - Math.cos(omega_n * t);
                    } else if (zeta < 1) {
                        // 欠阻尼
                        const phi = Math.atan(Math.sqrt(1 - zeta * zeta) / zeta);
                        responseValue = 1 - (Math.exp(-zeta * omega_n * t) / Math.sqrt(1 - zeta * zeta)) * 
                                         Math.sin(omega_d * t + phi);
                    } else if (zeta === 1) {
                        // 临界阻尼
                        responseValue = 1 - (1 + omega_n * t) * Math.exp(-omega_n * t);
                    } else {
                        // 过阻尼
                        const s1 = -zeta * omega_n + omega_n * Math.sqrt(zeta * zeta - 1);
                        const s2 = -zeta * omega_n - omega_n * Math.sqrt(zeta * zeta - 1);
                        responseValue = 1 - (s2 * Math.exp(s1 * t) - s1 * Math.exp(s2 * t)) / (s2 - s1);
                    }
                } else if (currentSignal === 'ramp') {
                    // 斜坡响应 - 简化计算
                    if (zeta < 1) {
                        // 欠阻尼
                        const phi = Math.atan(Math.sqrt(1 - zeta * zeta) / zeta);
                        responseValue = t - (2 * zeta / omega_n) + 
                                       (Math.exp(-zeta * omega_n * t) / (omega_n * Math.sqrt(1 - zeta * zeta))) * 
                                       Math.sin(omega_d * t + phi);
                    } else if (zeta === 1) {
                        // 临界阻尼
                        responseValue = t - (2 / omega_n) + (t + 2 / omega_n) * Math.exp(-omega_n * t);
                    } else {
                        // 过阻尼
                        const alpha1 = zeta - Math.sqrt(zeta * zeta - 1);
                        const alpha2 = zeta + Math.sqrt(zeta * zeta - 1);
                        responseValue = t - (2 * zeta / omega_n) + 
                                       (1 / (omega_n * Math.sqrt(zeta * zeta - 1))) * 
                                       ((1 / (2 * alpha2)) * Math.exp(-alpha1 * omega_n * t) - 
                                        (1 / (2 * alpha1)) * Math.exp(-alpha2 * omega_n * t));
                    }
                } else if (currentSignal === 'impulse') {
                    // 脉冲响应
                    if (zeta === 0) {
                        // 无阻尼
                        responseValue = omega_n * Math.sin(omega_n * t);
                    } else if (zeta < 1) {
                        // 欠阻尼
                        responseValue = (omega_n / Math.sqrt(1 - zeta * zeta)) * 
                                       Math.exp(-zeta * omega_n * t) * Math.sin(omega_d * t);
                    } else if (zeta === 1) {
                        // 临界阻尼
                        responseValue = omega_n * omega_n * t * Math.exp(-omega_n * t);
                    } else {
                        // 过阻尼
                        const s1 = -zeta * omega_n + omega_n * Math.sqrt(zeta * zeta - 1);
                        const s2 = -zeta * omega_n - omega_n * Math.sqrt(zeta * zeta - 1);
                        responseValue = (omega_n / (2 * Math.sqrt(zeta * zeta - 1))) * 
                                       (Math.exp(s1 * t) - Math.exp(s2 * t));
                    }
                }
                
                responseData.push(responseValue);
            }
            
            // 计算性能指标（仅对阶跃响应）
            let riseTime = 0, peakTime = 0, overshoot = 0, settlingTime = 0;
            
            if (currentSignal === 'step' && zeta < 1) {
                // 欠阻尼阶跃响应的性能指标
                const phi = Math.acos(zeta);
                riseTime = (Math.PI - phi) / omega_d;
                peakTime = Math.PI / omega_d;
                overshoot = Math.exp(-zeta * Math.PI / Math.sqrt(1 - zeta * zeta)) * 100;
                settlingTime = 4 / (zeta * omega_n); // 2%准则
            } else if (currentSignal === 'step' && zeta === 1) {
                // 临界阻尼阶跃响应
                riseTime = 2.2 / omega_n; // 近似值
                peakTime = 0;
                overshoot = 0;
                settlingTime = 5.833 / omega_n; // 近似值
            } else if (currentSignal === 'step' && zeta > 1) {
                // 过阻尼阶跃响应
                riseTime = (1 + 1.1 * zeta + 1.4 * zeta * zeta) / omega_n; // 近似值
                peakTime = 0;
                overshoot = 0;
                settlingTime = (6.6 * zeta - 1.7) / omega_n; // 近似值
            }
            
            // 更新性能指标显示
            if (currentSignal === 'step') {
                riseTimeElem.textContent = riseTime > 0 ? riseTime.toFixed(2) + ' s' : 'N/A';
                peakTimeElem.textContent = peakTime > 0 ? peakTime.toFixed(2) + ' s' : 'N/A';
                overshootElem.textContent = overshoot > 0 ? overshoot.toFixed(1) + ' %' : '0 %';
                settlingTimeElem.textContent = settlingTime > 0 ? settlingTime.toFixed(2) + ' s' : 'N/A';
            } else {
                riseTimeElem.textContent = 'N/A';
                peakTimeElem.textContent = 'N/A';
                overshootElem.textContent = 'N/A';
                settlingTimeElem.textContent = 'N/A';
            }
            
            // 更新系统描述
            updateSystemDescription();
            
            // 更新设计实验室状态
            if (currentSignal === 'step') {
                updateDesignLab(overshoot, settlingTime);
            }
            
            // 绘制图表
            drawChart(timeData, responseData, inputData);
        }
        
        // 获取信号名称
        function getSignalName(signal) {
            switch(signal) {
                case 'step': return '单位阶跃';
                case 'ramp': return '单位斜坡';
                case 'impulse': return '单位脉冲';
                default: return '系统';
            }
        }
        
        // 更新系统描述
        function updateSystemDescription() {
            let description = "";
            let signalName = getSignalName(currentSignal);
            
            if (zeta === 0) {
                description = `当前为无阻尼状态：${signalName}响应持续等幅振荡。`;
            } else if (zeta < 1) {
                description = `当前为欠阻尼状态：${signalName}响应快速但有振荡。`;
            } else if (zeta === 1) {
                description = `当前为临界阻尼状态：${signalName}响应最快且无超调。`;
            } else {
                description = `当前为过阻尼状态：${signalName}响应缓慢无振荡。`;
            }
            
            systemDescription.textContent = description;
        }
        
        // 更新设计实验室状态
        function updateDesignLab(overshoot = 0, settlingTime = 0) {
            const targetOvershoot = parseFloat(targetOvershootInput.value);
            const targetSettlingTime = parseFloat(targetSettlingTimeInput.value);
            
            // 检查超调量要求
            if (overshoot < targetOvershoot) {
                reqOvershoot.className = "requirement requirement-met";
                reqOvershoot.querySelector('.metric-value').textContent = overshoot.toFixed(1) + '% ✓';
            } else {
                reqOvershoot.className = "requirement requirement-not-met";
                reqOvershoot.querySelector('.metric-value').textContent = overshoot.toFixed(1) + '% ✗';
            }
            
            // 检查调节时间要求
            if (settlingTime < targetSettlingTime) {
                reqSettlingTime.className = "requirement requirement-met";
                reqSettlingTime.querySelector('.metric-value').textContent = settlingTime.toFixed(2) + 's ✓';
            } else {
                reqSettlingTime.className = "requirement requirement-not-met";
                reqSettlingTime.querySelector('.metric-value').textContent = settlingTime.toFixed(2) + 's ✗';
            }
            
            // 检查是否满足所有要求
            if (overshoot < targetOvershoot && settlingTime < targetSettlingTime) {
                successMessage.style.display = 'block';
            } else {
                successMessage.style.display = 'none';
            }
        }
        
        // 计算专家解
        function calculateExpertSolution() {
            const targetOvershoot = parseFloat(targetOvershootInput.value);
            const targetSettlingTime = parseFloat(targetSettlingTimeInput.value);
            
            // 根据目标性能计算推荐的系统参数
            // 这里使用简化的经验公式
            
            // 从超调量计算阻尼比
            let recommendedZeta = 0;
            if (targetOvershoot > 0) {
                recommendedZeta = Math.sqrt(Math.pow(Math.log(targetOvershoot / 100), 2) / 
                                           (Math.pow(Math.PI, 2) + Math.pow(Math.log(targetOvershoot / 100), 2)));
            } else {
                recommendedZeta = 1; // 如果超调量为0，推荐临界阻尼
            }
            
            // 从调节时间计算自然频率
            let recommendedOmega = 0;
            if (targetSettlingTime > 0) {
                recommendedOmega = 4 / (recommendedZeta * targetSettlingTime);
            } else {
                recommendedOmega = 5; // 默认值
            }
            
            // 限制参数在合理范围内
            recommendedZeta = Math.max(0.1, Math.min(1.5, recommendedZeta));
            recommendedOmega = Math.max(0.5, Math.min(10, recommendedOmega));
            
            // 更新专家解显示
            expertZeta.textContent = recommendedZeta.toFixed(2);
            expertOmega.textContent = recommendedOmega.toFixed(1);
        }
        
        // 窗口大小变化时重新绘制
        window.addEventListener('resize', function() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            updateSystem();
        });
        
        // 初始化
        window.onload = function() {
            initCanvas();
            calculateExpertSolution();
        };
    </script>
</body>
</html>